<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script>
      if (location.protocol === "http:" && location.hostname.endsWith("sm0ke.org")) {
        location.replace(
          `https://${location.host}${location.pathname}${location.search}${location.hash}`
        );
      }
    </script>
    <title>Support Chat | Beat Saber Modding Wiki</title>
    <link rel="shortcut icon" href="/assets/logo.png" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Source+Sans+3:wght@400;600;700&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/docsify-themeable@0/dist/css/theme-simple-dark.css"
    />
    <link rel="stylesheet" href="https://wiki.sm0ke.org/support/chat.css" />
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"></script>
    </head>
  <body class="support-page">
    <div class="layout">
      <aside class="sidebar">
        <div class="sidebar-nav" id="sidebar-content">Loading navigation...</div>
      </aside>

      <main class="content">
        <section class="chat-shell">
          <div class="chat-status">
            <div class="status-block">
              <span class="status-pill status-warn" id="status-pill">Connecting</span>
              <span class="status-pill status-error presence-pill" id="presence-pill">
                Support offline
              </span>
            </div>
            <div class="chat-id">Chat ID <span id="chat-id"></span></div>
          </div>
          <div class="chat-log" id="chat-log">
            <div class="empty-state" id="empty-state">
              <p>Say hello and our support team will jump in.</p>
            </div>
          </div>

          <footer class="chat-input">
            <div class="composer-tools">
              <button class="tool-btn" id="tool-image" type="button" title="Upload image">+</button>
            </div>
            <div class="input-wrap">
              <textarea
                id="message-input"
                rows="2"
                placeholder="Type a message or upload an image..."
              ></textarea>
              <div class="input-hint" id="input-hint">Shift + Enter for a new line.</div>
            </div>
            <button class="send-button" id="send-button" type="button">&gt;</button>
          </footer>
        </section>
      </main>
    </div>

    <input id="imgur-input" type="file" accept="image/*" hidden />

    <script>
      const CHAT_API_BASE = "https://bsm-api.sm0ke.org";
      const UPLOAD_API_PATH = "/api/uploads";
      const POLL_INTERVAL_MS = 4000;
      const STORAGE_KEYS = {
        userId: "supportChatUserId",
        token: "supportChatToken",
        intro: "supportChatIntroSent",
        notifyAsked: "supportChatNotifyAsked",
      };

      const ui = {
        log: document.getElementById("chat-log"),
        input: document.getElementById("message-input"),
        send: document.getElementById("send-button"),
        status: document.getElementById("status-pill"),
        chatId: document.getElementById("chat-id"),
        empty: document.getElementById("empty-state"),
        sidebar: document.getElementById("sidebar-content"),
        toolImage: document.getElementById("tool-image"),
        hint: document.getElementById("input-hint"),
        imgurInput: document.getElementById("imgur-input"),
      };

      const state = {
        userId: getOrCreateUserId(),
        conversationId: null,
        clientToken: localStorage.getItem(STORAGE_KEYS.token) || "",
        displayName: "",
        lastMessageAt: 0,
        renderedIds: new Set(),
        lastDayKey: "",
        messageMap: new Map(),
        notifiedIds: new Set(),
      };

      const defaultHint = "Shift + Enter for a new line.";
      const TEXTAREA_MIN_HEIGHT = 48;
      const TEXTAREA_MAX_HEIGHT = 160;

      state.conversationId = state.userId;
      state.displayName = `Guest (${state.userId})`;
      ui.chatId.textContent = state.userId;

      let markdownReady = false;
      let pollTimer = null;
      let notificationPrompted = false;
      let notificationSound = null;

      function getOrCreateUserId() {
        const existing = localStorage.getItem(STORAGE_KEYS.userId);
        if (existing) {
          return existing;
        }
        const generated = generateRandomText(6);
        localStorage.setItem(STORAGE_KEYS.userId, generated);
        return generated;
      }

      function generateRandomText(length) {
        const charset = "abcdefghijklmnopqrstuvwxyz0123456789";
        let result = "";
        for (let i = 0; i < length; i += 1) {
          const index = Math.floor(Math.random() * charset.length);
          result += charset[index];
        }
        return result;
      }

      function setStatus(text, tone) {
        ui.status.textContent = text;
        ui.status.classList.remove("status-ok", "status-warn", "status-error");
        if (tone === "ok") {
          ui.status.classList.add("status-ok");
        } else if (tone === "error") {
          ui.status.classList.add("status-error");
        } else {
          ui.status.classList.add("status-warn");
        }
      }

      function setPresence() {}

      function setHint(message, tone) {
        ui.hint.textContent = message;
        ui.hint.classList.remove("warn", "error", "ok");
        if (tone) {
          ui.hint.classList.add(tone);
        }
      }

      function resetHint() {
        setHint(defaultHint);
      }

      async function attemptNotificationPrompt(force = false) {
        if (!("Notification" in window)) {
          return false;
        }
        if (Notification.permission === "granted") {
          return true;
        }
        if (Notification.permission === "denied") {
          return false;
        }
        const askedBefore = localStorage.getItem(STORAGE_KEYS.notifyAsked) === "true";
        if (!force && (notificationPrompted || askedBefore)) {
          return false;
        }
        notificationPrompted = true;
        localStorage.setItem(STORAGE_KEYS.notifyAsked, "true");
        try {
          const permission = await Notification.requestPermission();
          if (permission === "default") {
            notificationPrompted = false;
            localStorage.removeItem(STORAGE_KEYS.notifyAsked);
          }
          return permission === "granted";
        } catch (error) {
          return false;
        }
      }

      function getNotificationSound() {
        if (notificationSound) {
          return notificationSound;
        }
        const AudioContextClass = window.AudioContext || window.webkitAudioContext;
        if (!AudioContextClass) {
          return null;
        }
        notificationSound = new AudioContextClass();
        return notificationSound;
      }

      function playNotificationSound() {
        const context = getNotificationSound();
        if (!context) {
          return;
        }
        const play = () => {
          const oscillator = context.createOscillator();
          const gain = context.createGain();
          oscillator.type = "sine";
          oscillator.frequency.value = 880;
          gain.gain.value = 0.08;
          oscillator.connect(gain);
          gain.connect(context.destination);
          oscillator.start();
          oscillator.stop(context.currentTime + 0.2);
        };
        if (context.state === "suspended") {
          context.resume().then(play).catch(() => null);
          return;
        }
        play();
      }

      function autoResizeTextarea() {
        ui.input.style.height = "auto";
        const next = Math.min(ui.input.scrollHeight, TEXTAREA_MAX_HEIGHT);
        ui.input.style.height = `${Math.max(next, TEXTAREA_MIN_HEIGHT)}px`;
      }

      function disableComposer(message) {
        ui.input.disabled = true;
        ui.send.disabled = true;
        ui.toolImage.disabled = true;
        ui.input.placeholder = message;
        ui.input.value = "";
        autoResizeTextarea();
      }

      function checkConfig() {
        if (!CHAT_API_BASE) {
          setStatus("Chat backend not configured", "error");
          disableComposer("Support chat is offline.");
          return false;
        }
        return true;
      }

      function apiUrl(path) {
        return CHAT_API_BASE.replace(/\/+$/, "") + path;
      }

      async function fetchJson(url, options = {}) {
        const response = await fetch(url, options);
        const text = await response.text();
        let data = {};
        if (text) {
          try {
            data = JSON.parse(text);
          } catch (error) {
            data = {};
          }
        }
        if (!response.ok) {
          const message = data.error || response.statusText || "Request failed";
          throw new Error(message);
        }
        return data;
      }

      function renderMarkdown(text) {
        if (!window.marked || !window.DOMPurify) {
          return { html: text, isHtml: false };
        }
        if (!markdownReady) {
          window.marked.setOptions({ breaks: true, gfm: true });
          markdownReady = true;
        }
        const dirty = window.marked.parse(formatSmallText(text || ""));
        return {
          html: window.DOMPurify.sanitize(dirty, { ADD_TAGS: ["small"] }),
          isHtml: true,
        };
      }

      function formatSmallText(text) {
        return text.replace(/(^|\n)-#\s?(.*?)(?=\n|$)/g, (match, prefix, content) => {
          if (!content.trim()) {
            return match;
          }
          return `${prefix}<small>${content.trim()}</small>`;
        });
      }

      function formatTime(timestamp) {
        if (!timestamp) {
          return "";
        }
        return new Date(timestamp).toLocaleTimeString([], {
          hour: "2-digit",
          minute: "2-digit",
        });
      }

      function dayKey(timestamp) {
        if (!timestamp) {
          return "";
        }
        return new Date(timestamp).toDateString();
      }

      function formatDayLabel(timestamp) {
        if (!timestamp) {
          return "";
        }
        const date = new Date(timestamp);
        const now = new Date();
        const startOfToday = new Date(now.getFullYear(), now.getMonth(), now.getDate());
        const startOfYesterday = new Date(startOfToday.getTime() - 86400000);
        if (date >= startOfToday) {
          return "Today";
        }
        if (date >= startOfYesterday) {
          return "Yesterday";
        }
        return date.toLocaleDateString();
      }

      function appendDayDivider(timestamp) {
        const divider = document.createElement("div");
        divider.className = "day-divider";
        const label = document.createElement("span");
        label.textContent = formatDayLabel(timestamp);
        divider.appendChild(label);
        ui.log.appendChild(divider);
      }

      function extractImageUrls(text) {
        const regex =
          /https?:\/\/(?:i\.|cdn\.)?allthepics\.net\/[^\s]+?\.(?:png|jpe?g|gif|webp)(?:\?[^\s]+)?/g;
        const matches = text.match(regex) || [];
        let cleaned = text;
        matches.forEach((url) => {
          cleaned = cleaned.replace(url, "").trim();
        });
        return { cleanedText: cleaned, images: matches };
      }

      function canModifyMessage(message) {
        return message.role === "user" && message.senderId === state.userId;
      }

      function buildMessageActions(message) {
        if (!canModifyMessage(message)) {
          return null;
        }
        const actions = document.createElement("div");
        actions.className = "message-actions";

        const edit = document.createElement("button");
        edit.type = "button";
        edit.className = "message-action";
        edit.textContent = "Edit";
        edit.addEventListener("click", () => handleEditMessage(message));

        const remove = document.createElement("button");
        remove.type = "button";
        remove.className = "message-action";
        remove.textContent = "Delete";
        remove.addEventListener("click", () => handleDeleteMessage(message));

        actions.appendChild(edit);
        actions.appendChild(remove);
        return actions;
      }

      function buildMessageElement(message) {
        const role = message.role === "support" ? "support" : message.role === "system" ? "system" : "user";
        const wrapper = document.createElement("div");
        wrapper.className = `message ${role}`;
        wrapper.dataset.id = message.id || "";

        const bubble = document.createElement("div");
        bubble.className = "bubble";

        const { cleanedText, images } = extractImageUrls(message.text || "");

        if (cleanedText) {
          const body = document.createElement("div");
          body.className = "body";
          const rendered = renderMarkdown(cleanedText);
          if (rendered.isHtml) {
            body.innerHTML = rendered.html;
          } else {
            body.textContent = rendered.html;
          }
          bubble.appendChild(body);
        }

        if (images.length) {
          const grid = document.createElement("div");
          grid.className = "image-grid";
          images.forEach((url) => {
            const img = document.createElement("img");
            img.src = url;
            img.alt = "Uploaded image";
            img.loading = "lazy";
            grid.appendChild(img);
          });
          bubble.appendChild(grid);
        }

        const time = document.createElement("div");
        time.className = "time";
        time.textContent = formatTime(message.createdAt);
        bubble.appendChild(time);

        wrapper.appendChild(bubble);
        const actions = buildMessageActions(message);
        if (actions) {
          wrapper.appendChild(actions);
        }
        return wrapper;
      }

      function updateEmptyState() {
        ui.empty.style.display = state.renderedIds.size ? "none" : "block";
      }

      function isNearBottom() {
        const offset = ui.log.scrollHeight - ui.log.scrollTop - ui.log.clientHeight;
        return offset < 120;
      }

      function scrollToBottom() {
        ui.log.scrollTop = ui.log.scrollHeight;
      }

      function renderMessages(messages, forceScroll) {
        const previousLastMessageAt = state.lastMessageAt;
        const offsetFromBottom = ui.log.scrollHeight - ui.log.scrollTop;
        const hadMessages = state.renderedIds.size > 0;
        ui.log.innerHTML = "";
        state.renderedIds = new Set();
        state.lastDayKey = "";
        state.lastMessageAt = 0;
        state.messageMap.clear();
        appendMessages(messages, forceScroll, previousLastMessageAt, true);
        if (!hadMessages || forceScroll) {
          scrollToBottom();
        } else {
          const nextScrollTop = Math.max(0, ui.log.scrollHeight - offsetFromBottom);
          ui.log.scrollTop = nextScrollTop;
        }
      }

      function appendMessages(messages, forceScroll, previousLastMessageAt = 0, skipScroll = false) {
        if (!Array.isArray(messages) || messages.length === 0) {
          updateEmptyState();
          return;
        }

        const sorted = [...messages].sort((a, b) => (a.createdAt || 0) - (b.createdAt || 0));
        let hasNew = false;

        sorted.forEach((message) => {
          if (!message || !message.id || state.renderedIds.has(message.id)) {
            return;
          }

          const key = dayKey(message.createdAt);
          if (key && key !== state.lastDayKey) {
            appendDayDivider(message.createdAt);
            state.lastDayKey = key;
          }

          state.renderedIds.add(message.id);
          const node = buildMessageElement(message);
          ui.log.appendChild(node);
          state.lastMessageAt = Math.max(state.lastMessageAt, message.createdAt || 0);
          state.messageMap.set(message.id, message);
          if (shouldNotify(message, previousLastMessageAt)) {
            state.notifiedIds.add(message.id);
            notifyMessage(message);
          }
          hasNew = true;
        });

        if (!skipScroll && hasNew && (forceScroll || isNearBottom())) {
          scrollToBottom();
        }

        updateEmptyState();
      }

      async function postMessage(text, role) {
        const payload = {
          conversationId: state.conversationId,
          senderId: state.userId,
          senderName: state.displayName,
          text,
          role,
          clientToken: state.clientToken,
        };

        const headers = { "Content-Type": "application/json" };
        if (state.clientToken) {
          headers["X-Client-Token"] = state.clientToken;
        }

        const data = await fetchJson(apiUrl("/api/messages"), {
          method: "POST",
          headers,
          body: JSON.stringify(payload),
        });

        if (data.clientToken && data.clientToken !== state.clientToken) {
          state.clientToken = data.clientToken;
          localStorage.setItem(STORAGE_KEYS.token, data.clientToken);
        }

        return data;
      }

      async function updateMessage(messageId, text) {
        const payload = {
          conversationId: state.conversationId,
          messageId,
          text,
          senderId: state.userId,
          clientToken: state.clientToken,
        };
        const headers = { "Content-Type": "application/json" };
        if (state.clientToken) {
          headers["X-Client-Token"] = state.clientToken;
        }
        const data = await fetchJson(apiUrl("/api/messages"), {
          method: "PATCH",
          headers,
          body: JSON.stringify(payload),
        });
        if (data && data.message) {
          state.messageMap.set(data.message.id, data.message);
          replaceMessageNode(data.message);
        }
      }

      async function deleteMessage(messageId) {
        const payload = {
          conversationId: state.conversationId,
          messageId,
          senderId: state.userId,
          clientToken: state.clientToken,
        };
        const headers = { "Content-Type": "application/json" };
        if (state.clientToken) {
          headers["X-Client-Token"] = state.clientToken;
        }
        await fetchJson(apiUrl("/api/messages"), {
          method: "DELETE",
          headers,
          body: JSON.stringify(payload),
        });
        removeMessageNode(messageId);
      }

      function replaceMessageNode(message) {
        const existing = ui.log.querySelector(`[data-id="${message.id}"]`);
        const node = buildMessageElement(message);
        if (existing) {
          existing.replaceWith(node);
        } else {
          state.renderedIds.add(message.id);
          ui.log.appendChild(node);
        }
      }

      function removeMessageNode(messageId) {
        const existing = ui.log.querySelector(`[data-id="${messageId}"]`);
        if (existing) {
          existing.remove();
        }
        state.renderedIds.delete(messageId);
        state.messageMap.delete(messageId);
        updateEmptyState();
      }

      async function handleEditMessage(message) {
        const current = message.text || "";
        const next = window.prompt("Edit message:", current);
        if (next === null) {
          return;
        }
        const trimmed = next.trim();
        if (!trimmed || trimmed === current) {
          return;
        }
        setHint("Saving edit...", "warn");
        try {
          await updateMessage(message.id, trimmed);
          setHint("Message updated.", "ok");
        } catch (error) {
          setHint("Edit failed.", "error");
        } finally {
          setTimeout(resetHint, 2500);
        }
      }

      async function handleDeleteMessage(message) {
        if (!window.confirm("Delete this message?")) {
          return;
        }
        setHint("Deleting message...", "warn");
        try {
          await deleteMessage(message.id);
          setHint("Message deleted.", "ok");
        } catch (error) {
          setHint("Delete failed.", "error");
        } finally {
          setTimeout(resetHint, 2500);
        }
      }

      async function loadMessages({ incremental = false } = {}) {
        const params = new URLSearchParams({ conversationId: state.conversationId });
        if (state.clientToken) {
          params.set("token", state.clientToken);
        }
        if (incremental && state.lastMessageAt) {
          params.set("after", String(state.lastMessageAt));
        }

        const data = await fetchJson(apiUrl(`/api/messages?${params.toString()}`));
        if (incremental) {
          const previousLastMessageAt = state.lastMessageAt;
          appendMessages(data.messages || [], false, previousLastMessageAt);
          return;
        }
        renderMessages(data.messages || [], false);
      }

      function shouldNotify(message, previousLastMessageAt) {
        if (!message || message.role === "user") {
          return false;
        }
        if (message.deletedAt) {
          return false;
        }
        if (!previousLastMessageAt || message.createdAt <= previousLastMessageAt) {
          return false;
        }
        if (state.notifiedIds.has(message.id)) {
          return false;
        }
        if (document.hasFocus()) {
          return false;
        }
        return true;
      }

      function notifyMessage(message) {
        if ("Notification" in window && Notification.permission === "granted") {
          const notification = new Notification("Support reply", {
            body: (message.text || "").slice(0, 160),
          });
          notification.onclick = () => window.focus();
          return;
        }
        playNotificationSound();
      }

      async function sendIntroMessage() {
        const introSent = localStorage.getItem(STORAGE_KEYS.intro) === "true";
        const text = introSent
          ? `Chat session resumed. User ID: ${state.userId}`
          : "Hello, I need assistance. I have tried turning off/on and waiting and read faq at https://wiki.sm0ke.org/#/faq";
        const data = await postMessage(text, "system");
        localStorage.setItem(STORAGE_KEYS.intro, "true");
        if (data && data.message) {
          const previousLastMessageAt = state.lastMessageAt;
          appendMessages([data.message], true, previousLastMessageAt);
        }
      }

      async function handleSend() {
        const text = ui.input.value.trim();
        if (!text) {
          return;
        }
        ui.send.disabled = true;
        try {
          const data = await postMessage(text, "user");
          ui.input.value = "";
          autoResizeTextarea();
          if (data && data.message) {
            const previousLastMessageAt = state.lastMessageAt;
            appendMessages([data.message], true, previousLastMessageAt);
          }
          setStatus("Online", "ok");
        } catch (error) {
          setStatus("Send failed", "error");
        } finally {
          ui.send.disabled = false;
        }
      }

      async function sendImageMessage(urls) {
        if (!urls) {
          return;
        }
        ui.send.disabled = true;
        try {
          const data = await postMessage(urls, "user");
          if (data && data.message) {
            const previousLastMessageAt = state.lastMessageAt;
            appendMessages([data.message], true, previousLastMessageAt);
          }
        } catch (error) {
          setHint("Image send failed.", "error");
        } finally {
          ui.send.disabled = false;
        }
      }

      function slugify(value) {
        return value
          .toLowerCase()
          .trim()
          .replace(/[\s_]+/g, "-")
          .replace(/[^a-z0-9-]/g, "")
          .replace(/-+/g, "-");
      }

      function normalizeDocsifyHref(rawHref) {
        if (!rawHref) {
          return rawHref;
        }
        if (rawHref.startsWith("http") || rawHref.startsWith("mailto:")) {
          return rawHref;
        }
        if (rawHref === "/") {
          return rawHref;
        }
        const [pathPart, hashPart] = rawHref.split("#");
        if (!pathPart) {
          return rawHref;
        }
        const trimmedPath = pathPart.replace(/^\/+/, "");
        if (!trimmedPath.endsWith(".md")) {
          return rawHref;
        }
        const base = trimmedPath.slice(0, -3);
        let next = `/#/${base}`;
        if (hashPart) {
          next += `?id=${slugify(hashPart)}`;
        }
        return next;
      }

      function rewriteSidebarLinks() {
        const links = ui.sidebar.querySelectorAll("a");
        links.forEach((link) => {
          const rawHref = link.getAttribute("href") || "";
          const updated = normalizeDocsifyHref(rawHref);
          if (updated && updated !== rawHref) {
            link.setAttribute("href", updated);
          }
        });
      }

      function highlightSidebar() {
        const currentHash = window.location.hash;
        const links = ui.sidebar.querySelectorAll("a");
        links.forEach((link) => {
          const href = link.getAttribute("href") || "";
          const normalized = href.startsWith("/#") ? `#${href.slice(2)}` : href;
          if (normalized && currentHash.startsWith(normalized)) {
            link.classList.add("active");
          }
        });
      }

      async function loadSidebar() {
        try {
          const response = await fetch("/_sidebar.md", { cache: "no-store" });
          if (!response.ok) {
            throw new Error("Failed");
          }
          const markdown = await response.text();
          const html = window.marked.parse(markdown);
          const safe = window.DOMPurify.sanitize(html, {
            ADD_TAGS: ["img"],
            ADD_ATTR: ["style", "href", "src", "alt", "title"],
          });
          ui.sidebar.innerHTML = safe;
          rewriteSidebarLinks();
          highlightSidebar();
        } catch (error) {
          ui.sidebar.textContent = "Unable to load navigation.";
        }
      }

      async function uploadToAllThePics(file) {
        const formData = new FormData();
        formData.append("source", file);
        const data = await fetchJson(apiUrl(UPLOAD_API_PATH), {
          method: "POST",
          body: formData,
        });
        const link =
          data?.url ||
          data?.image?.url ||
          data?.image?.display_url ||
          data?.image?.url_viewer ||
          data?.data?.url ||
          data?.data?.link;
        if (!link) {
          throw new Error("Upload failed");
        }
        return link;
      }

      async function handleImageUpload() {
        const files = Array.from(ui.imgurInput.files || []);
        ui.imgurInput.value = "";
        if (!files.length) {
          return;
        }
        setHint("Uploading image...", "warn");
        ui.send.disabled = true;
        ui.input.disabled = true;
        ui.toolImage.disabled = true;

        try {
          const links = [];
          for (const file of files) {
            const link = await uploadToAllThePics(file);
            links.push(link);
          }
          const joined = links.join(" ");
          if (ui.input.value.trim()) {
            ui.input.value = `${ui.input.value.trim()} ${joined}`;
            setHint("Image added.", "ok");
            autoResizeTextarea();
          } else {
            await sendImageMessage(joined);
            setHint("Image sent.", "ok");
          }
        } catch (error) {
          setHint("Image upload failed.", "error");
        } finally {
          ui.send.disabled = false;
          ui.input.disabled = false;
          ui.toolImage.disabled = false;
          setTimeout(resetHint, 2500);
        }
      }

      async function bootstrap() {
        loadSidebar();
        if (!checkConfig()) {
          return;
        }

        setStatus("Connecting", "warn");

        try {
          if (!state.clientToken) {
            await sendIntroMessage();
          }
          await loadMessages();
          setStatus("Online", "ok");
        } catch (error) {
          setStatus("Offline", "error");
        }

        pollTimer = setInterval(() => {
          loadMessages({ incremental: true }).catch(() => setStatus("Offline", "error"));
        }, POLL_INTERVAL_MS);
        attemptNotificationPrompt().catch(() => null);
      }

      document.addEventListener(
        "click",
        () => {
          attemptNotificationPrompt(true).catch(() => null);
          const context = getNotificationSound();
          if (context && context.state === "suspended") {
            context.resume().catch(() => null);
          }
        },
        { once: true }
      );

      ui.send.addEventListener("click", handleSend);
      ui.input.addEventListener("input", autoResizeTextarea);
      ui.input.addEventListener("keydown", (event) => {
        if (event.key === "Enter" && !event.shiftKey) {
          event.preventDefault();
          handleSend();
        }
      });
      ui.toolImage.addEventListener("click", () => ui.imgurInput.click());
      ui.imgurInput.addEventListener("change", handleImageUpload);

      autoResizeTextarea();
      bootstrap();
    </script>
  </body>
</html>

