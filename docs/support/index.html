<html>
  <head>
    <script>
      function fadeIn(elementId) {
        const element = document.getElementById(elementId);
        element.classList.remove("hidden");
        element.style.opacity = "1";
        void element.offsetWidth;
        element.classList.add("visible");
        element.style.opacity = "1";
      }

      function fadeOut(elementId) {
        const element = document.getElementById(elementId);
        element.style.opacity = "0";
        setTimeout(() => {
          element.classList.add("hidden");
        }, 1500);
      }

      function toggleFade(elementId) {
        const element = document.getElementById(elementId);
        if (element.classList.contains("hidden")) {
          element.classList.remove("hidden");
          void element.offsetWidth;
          element.classList.add("visible");
          element.style.opacity = "1";
        } else {
          element.style.opacity = "0";
          setTimeout(() => {
            if (element.style.opacity === "0") {
              element.classList.remove("visible");
              element.classList.add("hidden");
            }
          }, 1000);
        }
      }
    </script>
    <title>Chat | Beat Saber Modding Wiki</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="shortcut icon" href="/assets/logo.png" />
    <script src="https://cdn.tailwindcss.com"></script>
    <script
      defer
      src="https://cdn.jsdelivr.net/npm/@cometchat/chat-embed@1.x.x/dist/main.js"
    ></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"></script>
    <style>
      .fade {
        opacity: 1;
        transition: opacity 1s ease;
      }
      .visible {
        display: block;
        opacity: 1;
      }
      .markdown-spoiler {
        border-radius: 0.2rem;
        padding: 0 0.2rem;
        color: inherit;
        background-color: rgba(0, 0, 0, 0.15);
        cursor: pointer;
        transition: color 0.15s ease, background-color 0.15s ease;
      }
      .markdown-spoiler:not(.revealed) {
        color: transparent;
        background-color: currentColor;
        text-shadow: 0 0 6px rgba(0, 0, 0, 0.4);
      }
      .markdown-spoiler.revealed {
        color: inherit;
        background-color: rgba(0, 0, 0, 0.1);
      }
    </style>
  </head>
  <body style="overflow: hidden; background: black">
    <div
      style="z-index: -50"
      class="w-full h-full mt-0 m-0 border-0 fade rounded-none"
      id="chat"
    ></div>
    <script>
      window.addEventListener("DOMContentLoaded", (event) => {
        const COMETCHAT_CREDENTIALS = {
          appID: "16715605cbc276637",
          appRegion: "us",
          authKey: "e2aaea3afaa91a7a315164738582ee0a42e8202e",
        };
        const cometChat = CometChatApp.CometChat;
        const commandListenerId = "loginListener";
        const SUPPORT_UID = "support";
        const RECEIPT_TEXT = "Receved";

        function isLoginCommand(text = "") {
          return text.startsWith("/login");
        }

        function isReceiptMessage(text = "") {
          return text.trim() === RECEIPT_TEXT;
        }

        function sendReceipt() {
          const receiptMessage = new cometChat.TextMessage(
            SUPPORT_UID,
            RECEIPT_TEXT,
            cometChat.RECEIVER_TYPE.USER
          );
          cometChat
            .sendMessage(receiptMessage)
            .then(() => console.log("Receipt sent"))
            .catch((error) => console.error("Failed to send receipt:", error));
        }

        function handleCommand(text) {
          if (!isLoginCommand(text)) {
            return;
          }
          console.log("Command found:", text);
          const uid = text.replace("/login", "");
          localStorage.setItem("chatUser", uid);
          location.reload();
          sendReceipt();
        }

        function setupCommandDetection() {
          const messagesRequest = new cometChat.MessagesRequestBuilder()
            .setLimit(100)
            .setUID(SUPPORT_UID)
            .build();

          messagesRequest.fetchPrevious().then(
            (messages) => {
              const sortedMessages = [...messages].sort((a, b) => {
                const first =
                  typeof a.getSentAt === "function" ? a.getSentAt() : 0;
                const second =
                  typeof b.getSentAt === "function" ? b.getSentAt() : 0;
                return first - second;
              });

              const pendingCommands = [];

              sortedMessages.forEach((message) => {
                if (!(message instanceof cometChat.TextMessage)) {
                  return;
                }
                const text = (message.getText() || "").trim();
                if (isLoginCommand(text)) {
                  pendingCommands.push(text);
                  return;
                }
                if (isReceiptMessage(text) && pendingCommands.length) {
                  pendingCommands.shift();
                }
              });

              pendingCommands.forEach((commandText) => {
                handleCommand(commandText);
              });
            },
            (error) => {
              console.log("Error fetching messages:", error);
            }
          );

          // ensure duplicate listeners do not pile up on reload
          cometChat.removeMessageListener(commandListenerId);
          cometChat.addMessageListener(
            commandListenerId,
            new cometChat.MessageListener({
              onTextMessageReceived: (textMessage) => {
                const text = (textMessage.getText() || "").trim();
                if (isLoginCommand(text)) {
                  handleCommand(text);
                }
              },
            })
          );
        }

        let useruid =
          localStorage.getItem("chatUser") || generateRandomText(6);
        let usernew = localStorage.getItem("chatUser") === null;
        let userdisplay = "Guest (" + useruid + ")";
        let useravatar = "https://wiki.sm0ke.org/assets/logo.png";

        CometChatApp.init(COMETCHAT_CREDENTIALS)
          .then(() => {
            registerMarkdownFormatter();
            const user = new CometChatApp.CometChat.User(useruid);
            user.setName(userdisplay);
            user.setAvatar(useravatar);
            return CometChatApp.createOrUpdateUser(user);
          })
          .then((chatuser) => {
            localStorage.setItem("chatUser", chatuser.uid);
            return CometChatApp.login({ uid: chatuser.uid });
          })
          .then((loggedInUser) => {
            // Send automatic message to support
            const textMessage = new CometChatApp.CometChat.TextMessage(
              SUPPORT_UID, // receiver UID
              "Hello, I need assistance, my uid is " +
                loggedInUser.uid +
                "\n\nNote for user: If you get logged out, please use /login " +
                loggedInUser.uid +
                " to log back in", // message text
              CometChatApp.CometChat.RECEIVER_TYPE.USER
            );
            if (usernew) {
              CometChatApp.CometChat.sendMessage(textMessage)
                .then((message) => {
                  console.log("Auto message sent:", message);
                })
                .catch((error) => {
                  console.log("Message sending failed:", error);
                });
            }

            // Launch the widget
            return CometChatApp.launch({
              targetElementID: "chat",
              variantID: "6916997b5c867ddb852bdc2e",
              isDocked: false,
              height: "calc(100% + 1px)",
              width: "100%",
              roundedCorners: false,
              defaultID: "support",
              defaultType: "user",
            });
          })
          .then(() => {
            setupCommandDetection();
          })
          .catch((error) => console.error("[CometChat] Error:", error));
      });
      function generateRandomText(length) {
        const charset = "abcdefghijklmnopqrstuvwxyz0123456789";
        let randomText = "";
        for (let i = 0; i < length; i++) {
          const randomIndex = Math.floor(Math.random() * charset.length);
          randomText += charset[randomIndex];
        }
        return randomText;
      }

      // Basic Markdown helpers ------------------------------------------------
      let markdownConfigured = false;

      function ensureMarkdownDefaults() {
        if (markdownConfigured || !window.marked) {
          return;
        }
        window.marked.setOptions({
          breaks: true,
          gfm: true,
        });
        markdownConfigured = true;
      }

      const SPOILER_OPEN_TOKEN = "__CC_SPOILER_OPEN__";
      const SPOILER_CLOSE_TOKEN = "__CC_SPOILER_CLOSE__";
      const MARKDOWN_HINT_REGEX =
        /(\*\*|__|~~|`{1,3}|\|\||^>\s|^\s{0,3}([-*+]|\d+\.)\s|!\[|\[[^\]]+\]\([^)]+\)|\n\s*\n)/m;
      function preprocessDiscordMarkdown(markdownText = "") {
        if (!markdownText) {
          return "";
        }
        return markdownText
          .replace(/\r\n/g, "\n")
          .replace(/\|\|([\s\S]+?)\|\|/g, (_match, content) => {
            return `${SPOILER_OPEN_TOKEN}${content}${SPOILER_CLOSE_TOKEN}`;
          });
      }

      function postprocessDiscordMarkdown(html = "") {
        if (!html) {
          return "";
        }
        return html
          .split(SPOILER_OPEN_TOKEN)
          .join('<span class="markdown-spoiler">')
          .split(SPOILER_CLOSE_TOKEN)
          .join("</span>");
      }

      function applyMarkdownToElement(element, markdownText = "") {
        const rendered = toMarkdownHtml(markdownText);
        if (rendered.isPlain) {
          element.textContent = rendered.html;
        } else {
          element.innerHTML = rendered.html;
        }
        element.dataset.markdownRendered = "true";
      }

      function toMarkdownHtml(markdownText = "") {
        if (!window.marked || !window.DOMPurify) {
          return { html: markdownText, isPlain: true };
        }
        ensureMarkdownDefaults();
        const dirtyHtml = window.marked.parse(
          preprocessDiscordMarkdown(markdownText)
        );
        const enrichedHtml = postprocessDiscordMarkdown(dirtyHtml);
        return { html: window.DOMPurify.sanitize(enrichedHtml), isPlain: false };
      }

      function renderMarkdownBlock(element) {
        if (!element || element.dataset.markdownRendered === "true") {
          return;
        }
        const src = element.getAttribute("data-markdown-src");
        if (src) {
          fetch(src)
            .then((response) => {
              if (!response.ok) {
                throw new Error("Response " + response.status);
              }
              return response.text();
            })
            .then((markdownText) => {
              applyMarkdownToElement(element, markdownText);
            })
            .catch((error) => {
              element.innerHTML =
                '<p class="text-red-500">Unable to load content.</p>';
              console.error("[Markdown] Failed to load", src, error);
            });
          return;
        }
        const inlineText = element.textContent ? element.textContent.trim() : "";
        applyMarkdownToElement(element, inlineText);
      }

      function initMarkdownBlocks(scope = document) {
        const blocks = scope.querySelectorAll("[data-markdown]");
        blocks.forEach(renderMarkdownBlock);
      }

      window.renderMarkdown = function renderMarkdown(markdownText, target) {
        const element =
          typeof target === "string" ? document.querySelector(target) : target;
        if (!element) {
          console.warn("[Markdown] Target not found:", target);
          return;
        }
        applyMarkdownToElement(element, markdownText);
      };

      document.addEventListener("DOMContentLoaded", () => {
        initMarkdownBlocks();
      });

      document.addEventListener("click", (event) => {
        const spoiler = event.target.closest(".markdown-spoiler");
        if (spoiler) {
          spoiler.classList.toggle("revealed");
        }
      });

      function shouldProcessMarkdown(text = "") {
        if (!text || !text.trim()) {
          return false;
        }
        return MARKDOWN_HINT_REGEX.test(text);
      }

      function findFormatterHosts(possibleRoots = []) {
        const matches = [];
        const visited = new WeakSet();
        const queue = [];
        const MAX_NODES = 200;
        const MAX_DEPTH = 4;

        possibleRoots
          .filter(Boolean)
          .forEach((value, index) => {
            queue.push({
              value,
              depth: 0,
              path: `root[${index}]`,
            });
          });

        while (queue.length && visited.size < MAX_NODES) {
          const current = queue.shift();
          if (!current) {
            continue;
          }
          const { value, depth, path } = current;
          const type = typeof value;
          if (
            !value ||
            (type !== "object" && type !== "function") ||
            visited.has(value)
          ) {
            continue;
          }
          visited.add(value);

          const hasFormatterApi =
            typeof value.addFormatter === "function" ||
            typeof value.registerFormatter === "function" ||
            typeof value.register === "function" ||
            typeof value.setFormatters === "function";

          if (hasFormatterApi) {
            matches.push({ host: value, path });
          }

          if (depth >= MAX_DEPTH) {
            continue;
          }

          let childEntries = [];
          try {
            childEntries = Object.entries(value);
          } catch (error) {
            continue;
          }

          for (let idx = 0; idx < childEntries.length && idx < 25; idx += 1) {
            const [key, child] = childEntries[idx];
            if (!child || (typeof child !== "object" && typeof child !== "function")) {
              continue;
            }
            queue.push({
              value: child,
              depth: depth + 1,
              path: `${path}.${key}`,
            });
          }
        }
        return matches;
      }
      function registerMarkdownFormatter() {
        const staticFormatterApis = [
          CometChatApp?.CometChatTextFormatter,
          window.CometChatTextFormatter,
          CometChatApp?.TextFormatter,
        ]
          .map((host) => (host ? { host, path: "static" } : null))
          .filter(Boolean);

        const dynamicFormatterApis = findFormatterHosts([
          CometChatApp,
          window.CometChatApp,
          window.CometChatWidget,
          CometChatApp?.CometChat,
          window.VisualBuilder,
        ]);

        const seenHosts = new WeakSet();
        const formatterApis = [...staticFormatterApis, ...dynamicFormatterApis].filter(
          ({ host }) => {
            if (seenHosts.has(host)) {
              return false;
            }
            seenHosts.add(host);
            return true;
          }
        );

        if (!formatterApis.length) {
          console.warn(
            "[Markdown] No CometChat text formatter API detected; Markdown messages will render as plain text."
          );
          return;
        }

        const markdownFormatter = {
          id: "markdownFormatter",
          parse: (text = "") =>
            shouldProcessMarkdown(text) ? [{ start: 0, end: text.length }] : [],
          matches: (text = "") =>
            shouldProcessMarkdown(text) ? [{ start: 0, end: text.length }] : [],
          format: (text = "") =>
            shouldProcessMarkdown(text) ? toMarkdownHtml(text).html : text,
        };

        function tryRegister(hostEntry) {
          if (!hostEntry || !hostEntry.host) {
            return false;
          }
          const host = hostEntry.host;
          try {
            if (typeof host.addFormatter === "function") {
              host.addFormatter(markdownFormatter);
              console.debug("[Markdown] Registered via addFormatter on", hostEntry.path);
              return true;
            }
            if (typeof host.registerFormatter === "function") {
              host.registerFormatter(markdownFormatter);
              console.debug("[Markdown] Registered via registerFormatter on", hostEntry.path);
              return true;
            }
            if (typeof host.register === "function") {
              host.register(markdownFormatter);
              console.debug("[Markdown] Registered via register() on", hostEntry.path);
              return true;
            }
            if (
              typeof host.getFormatters === "function" &&
              typeof host.setFormatters === "function"
            ) {
              const current = host.getFormatters() || [];
              const next = current.filter(
                (item) => item && item.id !== markdownFormatter.id
              );
              next.push(markdownFormatter);
              host.setFormatters(next);
              console.debug("[Markdown] Registered via get/setFormatters on", hostEntry.path);
              return true;
            }
          } catch (error) {
            console.warn(
              "[Markdown] Failed to register Markdown formatter:",
              error
            );
          }
          return false;
        }

        const installed = formatterApis.some((api) => tryRegister(api));
        if (!installed) {
          console.warn(
            "[Markdown] Unable to register Markdown formatter with the current CometChat build."
          );
        }
      }
    </script>
  </body>
</html>
